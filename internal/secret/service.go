package secret

import (
	"context"
	"crypto/sha256"
	"errors"
	"fmt"
	"strings"
	"time"

	"bastienbyra.fr/bastienbyra/ByEmber/openapi/autogenerated"
	"bastienbyra.fr/bastienbyra/ByEmber/utils"
	"github.com/google/uuid"
)

type SecretService struct {
	secretRepository  SecretRepository
	encyrptionService *utils.EncryptionService
}

func (s *SecretService) CreateSecret(context context.Context, secretRequest autogenerated.SecretRequest) autogenerated.Secret {
	uuidValue := uuid.New()
	now := time.Now()

	encryptedContent, err := s.encyrptionService.Encrypt([]byte(secretRequest.Content))
	if err != nil {
		fmt.Println(err)
	}

	var hashPassword string
	if secretRequest.Password != nil && strings.TrimSpace(*secretRequest.Password) != "" {
		hash := sha256.Sum256([]byte(*secretRequest.Password))
		hashPassword = fmt.Sprintf("%x", hash)
	}

	secret := autogenerated.Secret{
		Id:        &uuidValue,
		Content:   encryptedContent,
		CreatedAt: &now,
		Duration:  secretRequest.Duration,
		Password:  &hashPassword,
		Views:     secretRequest.Views,
	}

	err = s.secretRepository.CreateSecret(context, &secret)

	if err != nil {
		fmt.Println("Failure while creating the secret %w", err)
	}

	return secret
}

func (s *SecretService) GetSecret(context context.Context, id string, password string) (*autogenerated.Secret, error) {
	// Hash the password if one has been given by the user
	var hashPassword string
	if strings.TrimSpace(password) != "" {
		hash := sha256.Sum256([]byte(password))
		hashPassword = fmt.Sprintf("%x", hash)
	}

	secret, err := s.secretRepository.GetSecret(context, id)
	if err != nil {
		return nil, err
	}

	// Check if the password is valid (whether if the secret need a password or not, and if it's match the secret password)
	if hashPassword == "" && *secret.Password == "" {
		return secret, nil
	}
	if hashPassword == "" && *secret.Password != "" {
		return nil, errors.New("the secret requires a password, please provide one")
	}
	if hashPassword != *secret.Password {
		return nil, errors.New("incorrect password")
	}

	// Reduce the secret view count by one
	secret.Views = secret.Views - 1

	if secret.Views > 0 {
		s.secretRepository.ReduceViewCountSecret(context, id)
	} else {
		// Delete the secret if it has no remaining view left
		// Normally, a Cronjob run to ensure it's deleted, but it's possible the cronjob haven't run by the time the user try to access the secret
		s.secretRepository.DeleteSecret(context, id)
	}

	content, err := s.encyrptionService.Decrypt(secret.Content)
	if err != nil {
		return nil, err
	}
	secret.Content = string(content)

	// TODO: Should only return the content of the secret
	return secret, nil
}
