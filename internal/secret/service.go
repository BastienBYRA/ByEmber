package secret

import (
	"context"
	"crypto/sha256"
	"fmt"
	"strings"
	"time"

	"bastienbyra.fr/bastienbyra/ByEmber/openapi/autogenerated"
	"bastienbyra.fr/bastienbyra/ByEmber/utils"
	"github.com/google/uuid"
)

type SecretService struct {
	secretRepository  SecretRepository
	encyrptionService *utils.EncryptionService
}

func (s *SecretService) CreateSecret(context context.Context, secretRequest autogenerated.SecretRequest) autogenerated.Secret {
	uuidValue := uuid.New()
	now := time.Now()

	encryptedContent, err := s.encyrptionService.Encrypt([]byte(secretRequest.Content))
	if err != nil {
		fmt.Println(err)
	}

	var hashPassword string
	if secretRequest.Password != nil && strings.TrimSpace(*secretRequest.Password) != "" {
		hash := sha256.Sum256([]byte(*secretRequest.Password))
		hashPassword = fmt.Sprintf("%x", hash)
	}

	secret := autogenerated.Secret{
		Id:        &uuidValue,
		Content:   encryptedContent,
		CreatedAt: &now,
		Duration:  secretRequest.Duration,
		Password:  &hashPassword,
		Views:     secretRequest.Views,
	}

	err = s.secretRepository.CreateSecret(context, &secret)

	if err != nil {
		fmt.Println("Failure while creating the secret %w", err)
	}

	return secret
}

func (s *SecretService) GetSecret(context context.Context, id string) (*autogenerated.Secret, error) {
	secret, err := s.secretRepository.GetSecret(context, id)
	if err != nil {
		return nil, err
	}

	// Retrieve the secret, reduce the view count by one
	secret.Views = secret.Views - 1

	if secret.Views > 1 {
		s.secretRepository.ReduceViewCountSecret(context, id)
	} else {
		// Delete the secret if it has only 1 remaining view left
		s.secretRepository.DeleteSecret(context, id)
	}

	content, err := s.encyrptionService.Decrypt(secret.Content)
	if err != nil {
		return nil, err
	}
	secret.Content = string(content)

	// TODO: Should only return the content of the secret
	return secret, nil
}
